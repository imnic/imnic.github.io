<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Nic]]></title>
  <link href="http://imnic.github.io/atom.xml" rel="self"/>
  <link href="http://imnic.github.io/"/>
  <updated>2014-10-11T11:46:38+08:00</updated>
  <id>http://imnic.github.io/</id>
  <author>
    <name><![CDATA[Nic]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://imnic.github.io/blog/2014/10/11/test/"/>
    <updated>2014-10-11T11:14:58+08:00</updated>
    <id>http://imnic.github.io/blog/2014/10/11/test</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView的编辑－－删除，插入及重新排序]]></title>
    <link href="http://imnic.github.io/blog/2014/10/10/bian-ji-uitableview/"/>
    <updated>2014-10-10T16:25:42+08:00</updated>
    <id>http://imnic.github.io/blog/2014/10/10/bian-ji-uitableview</id>
    <content type="html"><![CDATA[<p>这两天在开发表情商城的过程中，涉及到了已下载表情包的管理，因此自然想到使用 UITableView 来实现相关的功能，在此，对 UITableView 的编辑－－删除及重新排序进行一下简单的总结和归纳：</p>

<!-- more -->


<h2><strong>删除/插入Cell：</strong></h2>

<p>相关函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</span><span class='line'>- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;
</span><span class='line'>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;
</span><span class='line'>- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</span><span class='line'>- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</span><span class='line'>- (void)beginUpdates;
</span><span class='line'>- (void)endUpdates;</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>具体的流程可以参照下图：</p>

<p><img src="http://imnicblogphotos.qiniudn.com/table_view_editing.jpg" alt="table_view_editing" /></p>

<p>下面就这个流程图详细的解释一下：</p>

<h3>方法一：</h3>

<ol>
<li><p>用户点击编辑按钮时，此时分两种情况：</p>

<ul>
<li><p>我们可以给tableView发送 setEditing:animated: 消息。</p></li>
<li><p>当ViewController可以manage一个tableView时，比如，UITableViewController,或者在一个UIViewController中的loadView方法中，直接将一个tableView作为controller的view的情况下，当我们点击Navigation Bar上的Edit Button的时候，controller则会自动发送该消息给tableView。</p></li>
</ul>
</li>
<li><p>当tableView收到 setEditing:animated: 消息之后,tableView会掉用 tableView:canEditRowAtIndexPath: 方法，来进一步的确定哪些rows可以被编辑。补充：</p>

<ul>
<li><p>你也可以不实现该方法，在这种情况下，所有的rows都将可以被编辑。</p></li>
<li><p>而那些被指定了不能被编辑的rows将会忽略掉UITableViewCell的 editingStyle属性，当然也不会在处于编辑状态时向后缩进。</p></li>
<li><p>如果你想让rows可以被编辑，但是又不想显示出编辑按钮如删除或增加的话，你可以实现 tableView:editingStyleForRowAtIndexPath: 方法，然后返回 UITableViewCellEditingStyleNone 。</p></li>
</ul>
</li>
<li><p>接下来tableView会调用 tableView:editingStyleForRowAtIndexPath: 来确定编辑按钮的样式，可以是删除或者增加，当然如果你不实现该回调的话，默认的为UITableViewCellEditingStyleDelete。</p></li>
<li><p>当用户点击左侧的编辑按钮（删除或者增加）的时候，右侧会出现删除按钮，点击右侧的删除按钮则表示确认删除。</p></li>
<li><p>最后tableView会发送 tableView:commitEditingStyle:forRowAtIndexPath:给其 datasource，尽管该protocol是可选的，但是如果如果你想删除或者增加一行的话，你就必须实现该方法。在该方法中你必须做以下几件事：</p>

<ul>
<li><p>beginUpdates:当你想要在删除某一行的时候同时以动画的方式展现给用户的话，你必须要先调用该方法，该方法是跟endUpdates配对使用的，在此之间，你不能调用reloadData方法，否则，你必须自己实现动画的展现形式。</p></li>
<li><p>发送 deleteRowsAtIndexPaths:withRowAnimation: 或 insertRowsAtIndexPaths:withRowAnimation: 来展示删除。</p></li>
<li><p>更新你的 data-model，比如在array中增加或者删除object。</p></li>
<li><p>endUpdates:跟 beginUpdates 配对使用。</p></li>
</ul>


<p> <strong>注意:在endUpdates之前,如果你调用了 deleteRowsAtIndexPaths:withRowAnimation:时，
 一定记得要更新数据，比如删除新的数据在model－data中，否则应用将会崩溃，报错：<br/>
 Assertion failure in -[UITableView _endCellAnimationsWithContext:]</strong>。</p></li>
</ol>


<h3>方法二：</h3>

<p>除此之外，你也可以使用swipe-to-delete方法，但是具体的流程跟上面不太相同：</p>

<ol>
<li><p>当用户在一个cell上滑动的时候tableView会检测data source是否实现了 tableView:commitEditingStyle:forRowAtIndexPath: 方法，如果实现了的话他就会发送 setEditing:animated: 模式，然后进入编辑模式。<br/>
<strong>注意：在此方法中,你不能调用setEditing:animated:方法，如果由于某种原因必须要调用的话，你必须使用performSelector:withObject:afterDelay:方法来调用</strong>。</p></li>
<li><p>当用户开始滑动的时候会调用tableView:willBeginEditingRowAtIndexPath: ，当你点击删除或者点击空白处取消的时候则会调用 tableView:didEndEditingRowAtIndexPath:方法。</p></li>
<li><p>接下来你只需要在 tableView:commitEditingStyle:forRowAtIndexPath: 方法中实现跟上面一样的方法即可。</p></li>
</ol>


<h3>方法三：</h3>

<p>当然，你也可以不采用系统原生的编辑按钮，你可以自己在cell中自定义一个删除按钮，当用户点击删除按钮的时候，你只需要做如下的事情即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self.tableView beginUpdates];  
</span><span class='line'>[self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];  
</span><span class='line'>[self.resourceArray removeObjectAtIndex:indexPath.row];  
</span><span class='line'>[self.tableView endUpdates];</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当然你也可以直接：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self.resourceArray removeObjectAtIndex:indexPath.row];    
</span><span class='line'>[self.tableView reloadData];</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>但是这样用户体验并不好，不推荐！</p>

<p>而对于插入Cell的话，虽然我们也可以使用类似删除的系统原生方式（当tableView处于编辑模式时，点击cell左侧的编辑/插入按钮），但我们更倾向于使用在navigation bar上添加一个按钮，而具体的过程可以参照上面删除的流程。</p>

<h2><strong>重新排序</strong></h2>

<p>清楚了上面的流程之后我们在做排序的时候，我们在去做重新排序的时候就会比较简单了。<br/>
相关函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setShowsReorderControl:(BOOL)showsReorderControl;  
</span><span class='line'>- (void)setEditing:(BOOL)editing animated:(BOOL)animate;  
</span><span class='line'>- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;  
</span><span class='line'>- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath  
</span><span class='line'>- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>具体的流程可以参照下图：</p>

<p><img src="http://imnicblogphotos.qiniudn.com/table_view_moving.jpg" alt="table_view_moving" /></p>

<p>同样的，我们对这个流程也进行一下详细的解释：</p>

<ol>
<li><p>首先，当用户点击排序按钮时，tableView进入编辑模式，这也是分两种情况：</p>

<ul>
<li><p>我们可以给tableView发送 setEditing:animated: 消息。</p></li>
<li><p>当ViewController可以manage一个tableView时，比如，UITableViewController,或者在一个UIViewController中的loadView方法中，直接将一个tableView作为controller的view的情况下，当我们点击Navigation Bar上的Edit Button的时候，controller则会自动发送该消息给tableView。</p></li>
</ul>
</li>
<li><p>当tableView收到 setEditing:animated: 消息之后，他会给data source发送tableView:canMoveRowAtIndexPath:方法，在该方法中你可以筛选出来那些cell是可以被move而哪些不可以。</p></li>
<li><p>当用户拖动某一个cell上下移动的时候，就会调用</p>

<p> tableView:targetIndexPathForMoveFromRowAtIndexPath:toProposedIndexPath:</p>

<p> 这个方法中，我们可以指定cell的可移动范围，比如：</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSIndexPath *)tableView:(UITableView *)tableView
</span><span class='line'>        targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath
</span><span class='line'>        toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath   
</span><span class='line'>{
</span><span class='line'>    NSDictionary *section = [data objectAtIndex:sourceIndexPath.section];  
</span><span class='line'>    NSUInteger sectionCount = [[section valueForKey:@"content"] count];  
</span><span class='line'>    if (sourceIndexPath.section != proposedDestinationIndexPath.section)   
</span><span class='line'>    {  
</span><span class='line'>        NSUInteger rowInSourceSection =  
</span><span class='line'>             (sourceIndexPath.section > proposedDestinationIndexPath.section) ?  
</span><span class='line'>               0 : sectionCount - 1;  
</span><span class='line'>        return [NSIndexPath indexPathForRow:rowInSourceSection   inSection:sourceIndexPath.section];  
</span><span class='line'>    }   
</span><span class='line'>    else if (proposedDestinationIndexPath.row >= sectionCount)   
</span><span class='line'>    {  
</span><span class='line'>        return [NSIndexPath indexPathForRow:sectionCount - 1   inSection:sourceIndexPath.section];  
</span><span class='line'>    }  
</span><span class='line'>    // Allow the proposed destination.  
</span><span class='line'>    return proposedDestinationIndexPath;  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<ol>
<li>最后，当用户松开手之后，tableView就会给data source发送 tableView:moveRowAtIndexPath:toIndexPath: 消息，在该方法中我们可以更新model－data，比如：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath   
</span><span class='line'>{  
</span><span class='line'>    NSString *stringToMove = [self.reorderingRows objectAtIndex:sourceIndexPath.row];  
</span><span class='line'>    [self.reorderingRows removeObjectAtIndex:sourceIndexPath.row];  
</span><span class='line'>    [self.reorderingRows insertObject:stringToMove atIndex:destinationIndexPath.row];  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><strong>注意：我们如果想要显示reorder control，就必须设置cell 的 showsReorderControl属性为YES,同时必须实现tableView:moveRowAtIndexPath:toIndexPath: 方法</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress搭建自己的博客系统]]></title>
    <link href="http://imnic.github.io/blog/2014/10/09/configure-blog-with-octopress/"/>
    <updated>2014-10-09T16:55:54+08:00</updated>
    <id>http://imnic.github.io/blog/2014/10/09/configure-blog-with-octopress</id>
    <content type="html"><![CDATA[<p>一直都有写技术博客的想法，今天花了一些时间研究了一下如何使用Octopress来搭建自己的博客，从早上来就开始折腾，一直到现在，才算是全部搞定，那第一篇blog就先记录一下整个过程吧，也算是个良好的开端。</p>

<p>具体的步骤其实完全可以按照 <a href="http://octopress.org">Octopress</a>官网给的步骤一步一步来就可以了，在此做一些简单的归纳，具体的步骤可以分为三部分：</p>

<!-- more -->


<h3>第一部分：Octopress的安装及配置</h3>

<ol>
<li><p><strong>安装</strong> <a href="http://http://git-scm.com">Git</a>,如果你的电脑上已经安装过了，可以忽略此步骤。</p></li>
<li><p><strong>安装 Ruby：</strong>可以使用<a href="http://octopress.org/docs/setup/rbenv">Rbenv</a>或者<a href="http://octopress.org/docs/setup/rvm">RVM</a>两种方式安装，注意，我们要保证ruby的版本不能低于1.9.3，具体的查看方式为：在Terminal中输入 ruby &ndash;version 命令查。</p></li>
<li><strong>设置 Octopess：</strong></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octpress       
</span><span class='line'>cd octopress</span></code></pre></td></tr></table></div></figure>


<p> <br/>
4. <strong>安装依赖：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install bundler      
</span><span class='line'>rbenv rehash  
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<p>
5. <strong>安装octopres的默认主题：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>第二部分：Github Pages相关的部署及配置：</h3>

<ol>
<li><p>当然你首先要有个Github账号，然后建立一个新的repo，repo的名字为youraccountname.github.io。<br/>
<strong>注意:Github Pages已经将链接改为xxxx.github.io不再是xxxx.github.com</strong></p></li>
<li><p>在Terminal中输入 rake setup_github_pages 命令，输入之后，Terminal将会提示你输入你刚才新建的repo的url，比如：git@github.com:username/username.github.io.git，直接复制粘贴即可。</p></li>
</ol>


<h3>第三部分，写blog，常用的几个命令如下：</h3>

<ol>
<li><strong>rake new_post [&ldquo;the title of your blog&rdquo;]</strong>,使用此命令可以会在$OCTOPRESS/source/_posts中新建一个markdown文件,Mac下可以使用Mou对其进行编辑，这个文件就是我们blog的原文件。</li>
<li><strong>rake generate</strong></li>
<li><strong>git add .</strong></li>
<li><strong>git commit -m &ldquo;xxxxx&rdquo;</strong></li>
<li><strong>git push origin source</strong></li>
<li><strong>rake preview</strong>,输入完此命令，可以打开浏览器输入<a href="http://localhost:4000">http://localhost:4000</a>预览效果。</li>
<li><strong>rake deploy</strong></li>
</ol>


<p>PS:在使用rake deploy部署的过程中，我遇到了以下问题，git 提示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>! [rejected]        master -> master (non-fast-forward)
</span><span class='line'>error: failed to push some refs to 'https://github.com/yeesterbunny/yeesterbunny.github.com.git'
</span><span class='line'>hint: Updates were rejected because the tip of your current branch is behind
</span><span class='line'>hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
</span><span class='line'>hint: before pushing again.
</span><span class='line'>hint: See the 'Note about fast-forwards' in 'git push --help' for details.</span></code></pre></td></tr></table></div></figure>


<p>这里参照了<a href="http://allenyee.me/blog/2013/08/21/what-i-learned-from-hosting-octopress-on-github/">这篇博客</a>的解决办法。</p>

<p>以上就是使用Octopress来搭建个人博客的一些流程，另外我们可能还会需要更进一步的去定制你的个人博客，比如给你的博客添加评论和分享功能，定制你喜爱的主题等等，在此我就不再一一赘述，网上也有一些很不错的博客来介绍，比如<a href="http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/">这篇博客</a>就介绍的很详细。</p>

<p>最后，也算是给自己提个醒，以后无论是开发或者研究一项新技术或者遇到其他的技术问题的时候，第一时间不要着急去google或者stackoverflow去查答案，要先看看要没有官方文档，有的话要第一时间去翻阅文档，看看自己的方法有没有问题，因为网上的各种资料可能会有偏差，而且随着时间的推移，官方文档可能会有更新，但网上的资料可能还是当时的解决方案，因此，遇到问题一定要先从官方文档着手。</p>

<p>当然，在这里也要感谢前辈们的付出，我在学习的时候参照了他们的博客：<br/>
<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/</a></p>

<p><a href="http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/">http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/</a></p>

<p><a href="http://alvinzhu.me/blog/2013/10/02/an-zhuang-he-pei-zhi-octopress/">http://alvinzhu.me/blog/2013/10/02/an-zhuang-he-pei-zhi-octopress/</a></p>
]]></content>
  </entry>
  
</feed>
